#lang racket

(require (for-syntax racket/syntax
                     syntax/parse)
         profile
         math
         math/flonum
         (only-in ffi/unsafe -> ffi-lib _fun _ptr _double _long _int _int32
                  _array make-array-type ptr-ref
                  (array-ref carray-ref))
         ffi/unsafe/define)

(define-ffi-definer define-polys (ffi-lib "libpolynomial5"))
(define-ffi-definer define-libm (ffi-lib "libm"))

(define roots2 (_array _double 2))

(define-polys poly_quadroots (_fun _double _double _double
                                   (_double = -inf.0)
                                   (_double = +inf.0)
                                   (x1 : (_ptr o _double))
                                   (x2 : (_ptr o _double))
                                   -> (r : _int32)
                                   -> (take (list x1 x2) r)))

(define-polys poly_cubicroots (_fun _double _double _double _double
                                    (_double = -inf.0)
                                    (_double = +inf.0)
                                    (x1 : (_ptr o _double))
                                    (x2 : (_ptr o _double))
                                    (x3 : (_ptr o _double))
                                    -> (r : _int32)
                                    -> (take (list x1 x2 x3) r)))

(define-polys poly_quartroots (_fun _double _double _double _double _double
                                    (_double = -inf.0)
                                    (_double = +inf.0)
                                    (x1 : (_ptr o _double))
                                    (x2 : (_ptr o _double))
                                    (x3 : (_ptr o _double))
                                    (x4 : (_ptr o _double))
                                    -> (r : _int32)
                                    -> (take (list x1 x2 x3 x4) r)))

(define-polys poly_quintroots (_fun _double _double _double _double _double _double
                                    (_double = -inf.0)
                                    (_double = +inf.0)
                                    (x1 : (_ptr o _double))
                                    (x2 : (_ptr o _double))
                                    (x3 : (_ptr o _double))
                                    (x4 : (_ptr o _double))
                                    (x5 : (_ptr o _double))
                                    -> (r : _int32)
                                    -> (take (list x1 x2 x3 x4 x5) r)))

(define cprg (current-pseudo-random-generator))

(define (test-perf/quad N)
  (define scale 32000.0)
  (define count (min N 10000))
  (define polys (for/list ([i (in-range 0 count)])
                  (define a (random cprg))
                  (define b (random cprg))
                  (define A (* scale (random cprg)))
                  (define B (* scale (random cprg)))
                  (define ca (* A B))
                  (define cb (- (+ (* A b) (* a B))))
                  (define cc (* a b))
                  (list ca cb cc)))
  (define (test-rec polys N cnt)
    (if (<= N 0)
        cnt
        (let ([roots (for/list ([c (in-list polys)])
                       (apply poly_quadroots c))])
          (test-rec polys (- N count)
                    (+ cnt (caadr roots))
                    ))))
  (time (test-rec polys N 0)))

(define (test-perf/cubic N)
  (define scale 32000.0)
  (define count (min N 10000))
  (define polys (for/list ([i (in-range 0 count)])
                  (define a (random cprg))
                  (define b (random cprg))
                  (define c (random cprg))
                  (define A (* scale (random cprg)))
                  (define cb (* A (- a b c)))
                  (define cc (* A (+ (* a b) (* a c) (* b c))))
                  (define cd (* (- A) a b c))
                  (list A cb cc cd)))
  (define (test-rec polys N cnt)
    (if (<= N 0)
        cnt
        (let ([roots (for/list ([c (in-list polys)])
                       (apply poly_cubicroots c))])
          (test-rec polys (- N count) (+ cnt (caadr roots))))))
  (time (test-rec polys N 0)))

(define (test-perf/quart N)
  (define scale 32000.0)
  (define count (min N 10000))
  (define polys (for/list ([i (in-range 0 count)])
                  (define a (random cprg))
                  (define b (random cprg))
                  (define c (random cprg))
                  (define d (random cprg))
                  (define A (* scale (random cprg)))
                  (define c1 (* A (- a b c d)))
                  (define c2 (* A (+ (* a b) (* a c) (* b c) (* a d) (* b d) (* c d))))
                  (define c3 (* (- A) (+ (* a b c) (* a b d) (* a c d) (* b c d))))
                  (define c4 (* (- A) a b c d))
                  (list A c1 c2 c3 c4)))
  (define (test-rec polys N cnt)
    (if (<= N 0)
        cnt
        (let ([roots (for/list ([c (in-list polys)])
                       (apply poly_quartroots c))])
          (test-rec polys (- N count) (+ cnt (caadr roots))))))
  (time (test-rec polys N 0)))

(define (test-perf/quint N)
  (define scale 32000.0)
  (define count (min N 10000))
  (define polys (for/list ([i (in-range 0 count)])
                  (define a (random cprg))
                  (define b (random cprg))
                  (define c (random cprg))
                  (define d (random cprg))
                  (define e (random cprg))
                  (define A (* scale (random cprg)))
                  (define ab (* a b))
                  (define cd (* c d))
                  (define fc (- A (* ab cd e)))
                  (define ec (* A (+ (* ab cd) (* ab c e) (* ab d e) (* a cd e) (* b cd e))))
                  (define dc (* A (- (* ab c) (* ab d) (* a cd) (* b cd) (* ab e)
                                     (* a c e) (* b c e) (* a d e) (* b d e) (* cd e))))
                  (define cc (* A (+ ab (* a c) (* b c) (* a d) (* b d) (* d c) (* a e)
                                     (* b e) (* c e) (* d e))))
                  (define bc (* A (- a b c d e)))
                  (list A bc cc dc ec fc)))
  (define (test-rec polys N cnt)
    (if (<= N 0)
        cnt
        (let ([roots (for/list ([c (in-list polys)])
                       (apply poly_quintroots c))])
          (test-rec polys (- N count) (+ cnt (caadr roots))))))
  (time (test-rec polys N 0)))

;; (profile-thunk (thunk (test-perf/quad 1000000)))
;; (profile-thunk (thunk (test-perf/cubic 100000)))
;; (profile-thunk (thunk (test-perf/quart 100000)))
;; (profile-thunk (thunk (test-perf/quint 100000)))

(test-perf/quad 1000000)
(test-perf/cubic 100000)
(test-perf/quart 100000)
(test-perf/quint 100000)
